generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Role {
  id        String   @id @default(cuid())
  name      String   @unique
  label     String
  createdAt DateTime @default(now())

  users           User[]
  rolePermissions RolePermission[]
}

enum Goal {
  UPSC
  APPSC
  TGPSC
}

enum CourseStatus {
  UNPUBLISHED
  PUBLISH_PUBLIC
  PUBLISH_PRIVATE
  EXPIRED
}

enum AccessType {
  SINGLE
  MULTIPLE
  LIFETIME
  EXPIRY_DATE
}

enum StudentAnswerStatus {
  NOT_VISITED
  UNANSWERED
  ANSWERED
  MARKED_FOR_REVIEW
  ANSWERED_AND_MARKED_FOR_REVIEW
}

enum QuestionReportStatus {
  OPEN
  RESOLVED
  DISMISSED
}

enum PaymentStatus {
  PENDING
  VERIFIED
  REJECTED
}

model User {
  id             String    @id @default(cuid())
  name           String
  email          String    @unique
  password       String
  mobile         String    @unique
  profilePicture String?
  roleId         String?
  role           Role?     @relation(fields: [roleId], references: [id])
  isVerified     Boolean   @default(false)
  status         String    @default("ACTIVE")
  lastLogin      DateTime?
  createdAt      DateTime  @default(now())

  questions               Question[]
  uploadedAttachments     Attachment[]
  userPermissions         UserPermission[] // optional: for per-user overrides
  StudentTestAttempt      StudentTestAttempt[]
  reportedQuestionReports QuestionReport[]        @relation("ReportedByUser") // <-- fixed name
  resolvedQuestionReports QuestionReport[]        @relation("ResolvedByAdmin")
  paymentRequests         PaymentRequest[]
  verifiedRequests        PaymentRequest[]        @relation("VerifiedBy")
  enrollments             CourseEnrollment[]
  PaymentTransaction      PaymentTransaction[]
  UserLastOpenedCourse    UserLastOpenedCourse[]
  CourseContentProgress   CourseContentProgress[]
  UserCourseLastContent   UserCourseLastContent[]
}

model Course {
  id          String       @id @default(cuid())
  name        String
  description Json
  goal        Goal
  thumbnail   String?
  videoUrl    String?
  status      CourseStatus @default(UNPUBLISHED)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  courseSubjects        CourseSubject[]
  videoFolders          VideoFolder[]
  tests                 Test[]
  contents              CourseContent[]
  contentFolders        CourseContentFolder[]
  faqs                  Faq[]
  enrollments           CourseEnrollment[]
  paymentRequests       PaymentRequest[]
  accessType            AccessType
  pricingOptions        CoursePricingOption[]
  installments          CourseInstallment[]
  PaymentTransaction    PaymentTransaction[]
  UserLastOpenedCourse  UserLastOpenedCourse[]
  CourseContentProgress CourseContentProgress[]
  UserCourseLastContent UserCourseLastContent[]
}

model CoursePricingOption {
  id             String    @id @default(cuid())
  courseId       String
  durationInDays Int? // For SINGLE or MULTIPLE
  expiryDate     DateTime? // For EXPIRY_DATE
  price          Float
  discount       Float     @default(0)
  effectivePrice Float // price - discount
  promoted       Boolean   @default(false)

  course             Course               @relation(fields: [courseId], references: [id], onDelete: Cascade)
  installments       CourseInstallment[]
  CourseEnrollment   CourseEnrollment[]
  PaymentTransaction PaymentTransaction[]
  PaymentRequest     PaymentRequest[]
}

model CourseInstallment {
  id              String   @id @default(cuid())
  courseId        String
  pricingOptionId String
  label           String // e.g. "1st installment", "Initial Payment"
  amount          Float
  dueDate         DateTime
  isPaid          Boolean  @default(false)

  course               Course              @relation(fields: [courseId], references: [id], onDelete: Cascade)
  pricingOption        CoursePricingOption @relation(fields: [pricingOptionId], references: [id], onDelete: Cascade)
  paymentTransactionId String?             @unique
  paymentTransaction   PaymentTransaction? @relation(fields: [paymentTransactionId], references: [id])
  PaymentRequest       PaymentRequest[]
}

enum CourseContentType {
  FOLDER
  VIDEO
  TEST
  DOCUMENT
  IMAGE
}

model CourseContentFolder {
  id        String                @id @default(cuid())
  name      String
  courseId  String
  parentId  String?
  course    Course                @relation(fields: [courseId], references: [id], onDelete: Cascade)
  parent    CourseContentFolder?  @relation("SubFolders", fields: [parentId], references: [id])
  children  CourseContentFolder[] @relation("SubFolders")
  contents  CourseContent[]
  createdAt DateTime              @default(now())
}

model CourseContent {
  id             String            @id @default(cuid())
  name           String
  type           CourseContentType
  url            String?           @db.Text
  folderId       String
  courseId       String
  isDownloadable Boolean           @default(true)

  folder CourseContentFolder @relation(fields: [folderId], references: [id], onDelete: Cascade)
  course Course              @relation(fields: [courseId], references: [id], onDelete: Cascade)

  linkedTestId String?
  linkedTest   Test?   @relation("TestToContent", fields: [linkedTestId], references: [id], onDelete: SetNull)

  linkedVideoId String?
  linkedVideo   Video?  @relation("VideoToContent", fields: [linkedVideoId], references: [id], onDelete: SetNull)

  linkedAttachmentId String?
  linkedAttachment   Attachment? @relation("AttachmentToContent", fields: [linkedAttachmentId], references: [id], onDelete: SetNull)

  createdAt             DateTime                @default(now())
  CourseContentProgress CourseContentProgress[]
  UserCourseLastContent UserCourseLastContent[]
}

model Subject {
  id             String          @id @default(cuid())
  name           String
  chapters       Chapter[]
  courseSubjects CourseSubject[]
}

// Join table
model CourseSubject {
  id        String @id @default(cuid())
  courseId  String
  subjectId String

  course  Course  @relation(fields: [courseId], references: [id], onDelete: Cascade)
  subject Subject @relation(fields: [subjectId], references: [id])

  @@unique([courseId, subjectId]) // Prevent duplicates
}

model Chapter {
  id        String  @id @default(cuid())
  name      String
  subjectId String
  subject   Subject @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  topics    Topic[]
}

model Topic {
  id        String     @id @default(cuid())
  name      String
  chapterId String
  chapter   Chapter    @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  subTopics SubTopic[]
}

model SubTopic {
  id        String     @id @default(cuid())
  name      String
  topicId   String
  topic     Topic      @relation(fields: [topicId], references: [id], onDelete: Cascade)
  questions Question[]
}

model Question {
  id                String              @id @default(cuid())
  question          Json
  type              QuestionType
  correctType       AnswerType
  paragraph         Json?
  parentId          String?
  parent            Question?           @relation("ComprehensiveParent", fields: [parentId], references: [id], onDelete: Cascade)
  children          Question[]          @relation("ComprehensiveParent")
  options           Option[]
  explanation       Json?
  tags              Tag[]               @relation("QuestionTags")
  subTopicId        String?
  subTopic          SubTopic?           @relation(fields: [subTopicId], references: [id])
  attachments       Attachment[]
  pools             QuestionPool[]
  testQuestions     TestQuestion[]
  createdById       String
  createdBy         User                @relation(fields: [createdById], references: [id])
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  StudentTestAnswer StudentTestAnswer[]

  // Use explicit relation names
  reports      QuestionReport[] @relation("ReportedMainQuestion")
  childReports QuestionReport[] @relation("ReportedChildQuestion")
}

model Option {
  id         String   @id @default(cuid())
  value      String
  correct    Boolean  @default(false)
  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
}

model VideoFolder {
  id        String   @id @default(cuid())
  name      String
  courseId  String // Updated to reference Course
  course    Course   @relation(fields: [courseId], references: [id], onDelete: Cascade) // Belongs to Course
  videos    Video[] // Updated relation to Video
  tags      Tag[]    @relation("FolderTags")
  createdAt DateTime @default(now())
}

model Video {
  id             String          @id @default(cuid())
  url            String
  title          String
  description    String?
  folderId       String // Updated to reference VideoFolder
  folder         VideoFolder     @relation(fields: [folderId], references: [id], onDelete: Cascade) // Belongs to VideoFolder
  courseContents CourseContent[] @relation("VideoToContent")
}

model Tag {
  id           String        @id @default(cuid())
  name         String        @unique
  questions    Question[]    @relation("QuestionTags")
  videoFolders VideoFolder[] @relation("FolderTags")
  tests        Test[]        @relation("TestTags")
}

model Attachment {
  id             String          @id @default(cuid())
  type           AttachmentType
  url            String // Firebase URL
  questionId     String
  question       Question        @relation(fields: [questionId], references: [id], onDelete: Cascade)
  uploadedById   String?
  uploadedBy     User?           @relation(fields: [uploadedById], references: [id])
  courseContents CourseContent[] @relation("AttachmentToContent")
}

enum QuestionType {
  OBJECTIVE
  DESCRIPTIVE
  COMPREHENSIVE
}

enum AnswerType {
  SINGLE
  MULTIPLE
}

enum AttachmentType {
  IMAGE
  VIDEO
  PDF
}

model Pool {
  id        String         @id @default(cuid())
  name      String
  createdAt DateTime       @default(now())
  questions QuestionPool[] // Many-to-many via join table
}

model QuestionPool {
  id     String @id @default(cuid())
  pool   Pool   @relation(fields: [poolId], references: [id], onDelete: Cascade)
  poolId String

  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionId String

  @@unique([poolId, questionId]) // Prevent duplicate question entries in the same pool
}

model Test {
  id                  String               @id @default(cuid())
  name                String
  durationMin         Int // Total duration in minutes
  instructions        Json?
  tags                Tag[]                @relation("TestTags")
  type                String // Example: "MOCK", "PRACTICE", etc.
  allowNegative       Boolean              @default(false)
  isMultiSection      Boolean              @default(false)
  sections            TestSection[]
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  courseId            String?
  course              Course?              @relation(fields: [courseId], references: [id], onDelete: Cascade)
  courseContents      CourseContent[]      @relation("TestToContent")
  StudentTestAttempt  StudentTestAttempt[]
  attemptType         AttemptType          @default(UNLIMITED)
  maxAttempts         Int? // Only used if attemptType == MULTIPLE
  freeMaterial        FreeMaterial?
  FreeMaterialContent FreeMaterialContent?
}

model TestSection {
  id                 String               @id @default(cuid())
  name               String
  marksPerQn         Float
  negativeMarks      Float? // Nullable if not used
  testId             String
  test               Test                 @relation(fields: [testId], references: [id], onDelete: Cascade)
  questions          TestQuestion[]
  StudentTestAnswer  StudentTestAnswer[]
  StudentSectionStat StudentSectionStat[]
  QuestionReport     QuestionReport[]
}

model TestQuestion {
  id         String @id @default(cuid())
  questionId String
  sectionId  String

  question         Question    @relation(fields: [questionId], references: [id], onDelete: Cascade)
  section          TestSection @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  questionSnapshot Json?
  marks            Float?
  negativeMarks    Float?

  @@unique([questionId, sectionId])
}

model Faq {
  id        String   @id @default(cuid())
  courseId  String
  question  String   @db.Text
  answer    String   @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  course Course @relation(fields: [courseId], references: [id], onDelete: Cascade)
}

model Permission {
  id        String   @id @default(cuid())
  name      String   @unique // e.g. "course.create"
  label     String // e.g. "Create Course"
  createdAt DateTime @default(now())

  rolePermissions RolePermission[]
  userPermissions UserPermission[]
}

model RolePermission {
  id           String @id @default(cuid())
  roleId       String
  permissionId String

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([roleId, permissionId])
}

model UserPermission {
  id           String @id @default(cuid())
  userId       String
  permissionId String

  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([userId, permissionId])
}

model StudentTestAttempt {
  id          String    @id @default(cuid())
  userId      String
  testId      String
  startedAt   DateTime  @default(now())
  submittedAt DateTime?

  // Summary metrics
  totalTimeTaken   Int? // in seconds
  totalMarks       Float? // sum of correct scores
  negativeMarks    Float? // sum of negative marks
  finalScore       Float? // totalMarks - negativeMarks
  correctCount     Int? // number of correct answers
  wrongCount       Int? // number of wrong answers
  unansweredCount  Int? // number of unanswered
  answeredCount    Int? // total - unanswered
  avgTimePerQn     Float? // in seconds
  maxPossibleMarks Float?

  user           User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  test           Test                 @relation(fields: [testId], references: [id], onDelete: Cascade)
  answers        StudentTestAnswer[]
  sectionStats   StudentSectionStat[] // ✅ new
  QuestionReport QuestionReport[]
}

model StudentTestAnswer {
  id         String @id @default(cuid())
  attemptId  String
  questionId String
  sectionId  String

  selectedAnswer   Json?
  markedForReview  Boolean             @default(false)
  status           StudentAnswerStatus @default(UNANSWERED)
  timeTakenSeconds Int                 @default(0)

  // Evaluation metrics
  isCorrect   Boolean? // after evaluation
  marksScored Float? // positive or negative value

  attempt  StudentTestAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  question Question           @relation(fields: [questionId], references: [id], onDelete: Cascade)
  section  TestSection        @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  @@unique([attemptId, questionId])
}

model StudentSectionStat {
  id        String @id @default(cuid())
  attemptId String
  sectionId String

  timeTaken       Int    @default(0) // in seconds
  correctCount    Int    @default(0)
  wrongCount      Int    @default(0)
  unansweredCount Int    @default(0)
  marksScored     Float? // net (positive - negative)

  attempt StudentTestAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  section TestSection        @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  @@unique([attemptId, sectionId])
}

model QuestionReport {
  id                String               @id @default(cuid())
  attemptId         String
  questionId        String
  childQuestionId   String?
  sectionId         String
  reportedBy        String
  resolvedBy        String?
  reason            String               @db.Text
  createdAt         DateTime             @default(now())
  status            QuestionReportStatus @default(OPEN)
  resolved          Boolean              @default(false)
  resolutionRemarks String?
  resolvedAt        DateTime?

  // Relations
  reportedByUser User               @relation("ReportedByUser", fields: [reportedBy], references: [id])
  resolvedByUser User?              @relation("ResolvedByAdmin", fields: [resolvedBy], references: [id])
  attempt        StudentTestAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)

  // Add relation name here
  question      Question  @relation("ReportedMainQuestion", fields: [questionId], references: [id], onDelete: Cascade)
  childQuestion Question? @relation("ReportedChildQuestion", fields: [childQuestionId], references: [id], onDelete: Cascade)

  section TestSection @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  @@index([attemptId])
  @@index([questionId])
  @@index([sectionId])
}

model FreeMaterial {
  id          String           @id @default(cuid())
  title       String
  description String?
  type        FreeMaterialType
  videoId     String?
  documentUrl String?          @db.Text
  testId      String?          @unique
  createdAt   DateTime         @default(now())

  test Test? @relation(fields: [testId], references: [id], onDelete: Cascade)
}

enum FreeMaterialType {
  VIDEO
  DOCUMENT
  TEST
}

enum AttemptType {
  SINGLE
  MULTIPLE
  UNLIMITED
}

model FreeMaterialFolder {
  id        String                @id @default(cuid())
  name      String
  type      FreeMaterialType
  parentId  String?
  parent    FreeMaterialFolder?   @relation("FreeMaterialSubFolders", fields: [parentId], references: [id])
  children  FreeMaterialFolder[]  @relation("FreeMaterialSubFolders")
  contents  FreeMaterialContent[]
  createdAt DateTime              @default(now())
}

model FreeMaterialContent {
  id          String             @id @default(cuid())
  title       String
  type        FreeMaterialType
  folderId    String
  folder      FreeMaterialFolder @relation(fields: [folderId], references: [id], onDelete: Cascade)
  videoId     String?
  documentUrl String?            @db.Text
  testId      String?            @unique
  createdAt   DateTime           @default(now())

  test Test? @relation(fields: [testId], references: [id])
}

model PaymentRequest {
  id            String        @id @default(cuid())
  userId        String
  courseId      String
  screenshotUrl String        @db.Text
  amountPaid    Float?
  status        PaymentStatus @default(PENDING)
  adminNote     String?       @db.Text
  createdAt     DateTime      @default(now())
  verifiedAt    DateTime?
  verifiedById  String?

  utrNumber       String?              @unique @db.VarChar(50)
  pricingOptionId String?
  pricingOption   CoursePricingOption? @relation(fields: [pricingOptionId], references: [id])

  installmentId String?
  installment   CourseInstallment? @relation(fields: [installmentId], references: [id])

  user       User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  course     Course @relation(fields: [courseId], references: [id], onDelete: Cascade)
  verifiedBy User?  @relation("VerifiedBy", fields: [verifiedById], references: [id])
}

model CourseEnrollment {
  id              String     @id @default(cuid())
  userId          String
  courseId        String
  startDate       DateTime
  endDate         DateTime
  accessType      AccessType
  pricingOptionId String?
  addedByAdmin    Boolean    @default(false)
  createdAt       DateTime   @default(now())

  user                 User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  course               Course                @relation(fields: [courseId], references: [id], onDelete: Cascade)
  pricingOption        CoursePricingOption?  @relation(fields: [pricingOptionId], references: [id])
  UserLastOpenedCourse UserLastOpenedCourse?

  @@unique([userId, courseId])
}

model PaymentTransaction {
  id                String        @id @default(cuid())
  userId            String
  courseId          String
  pricingOptionId   String?
  razorpayOrderId   String
  razorpayPaymentId String?       @unique
  amount            Float
  currency          String
  status            PaymentStatus
  createdAt         DateTime      @default(now())

  user              User                 @relation(fields: [userId], references: [id])
  course            Course               @relation(fields: [courseId], references: [id])
  pricingOption     CoursePricingOption? @relation(fields: [pricingOptionId], references: [id])
  courseInstallment CourseInstallment?
}

model UserLastOpenedCourse {
  userId       String   @id
  enrollmentId String   @unique
  courseId     String?
  updatedAt    DateTime @default(now())

  user       User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  enrollment CourseEnrollment @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)
  Course     Course?          @relation(fields: [courseId], references: [id])
}

model CourseContentProgress {
  id          String   @id @default(cuid())
  userId      String
  courseId    String
  contentId   String
  isCompleted Boolean  @default(false)
  updatedAt   DateTime @updatedAt

  user    User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  course  Course        @relation(fields: [courseId], references: [id], onDelete: Cascade)
  content CourseContent @relation(fields: [contentId], references: [id], onDelete: Cascade)

  @@unique([userId, contentId])
}

model UserCourseLastContent {
  id        String   @id @default(cuid())
  userId    String
  courseId  String
  contentId String
  folderId  String?
  updatedAt DateTime @updatedAt

  user    User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  course  Course        @relation(fields: [courseId], references: [id], onDelete: Cascade)
  content CourseContent @relation(fields: [contentId], references: [id], onDelete: Cascade)

  @@unique([userId, courseId]) // only one record per user per course
}
